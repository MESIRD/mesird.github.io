---
layout: post
title:  "UITableView overview"
date:   2016-10-23 22:04:52
categories: iOS
tags: iOS
---

UITableView is a very powerful list view provided by Apple, basically every single app on App Store use this widget to create a list of things in one page.

As a very frequently used view in iOS, we must know how to initialize, configure and display it in the correct way. In this passage, I will introduce the simple and advanced usage of UITableView which can help you to develop better.

## Basic usage

**Initialization**

```
UITableView *tableView = [[UITableView alloc] initWithFrame:frame style:style];
```

TableView has two types of style, `UITableViewStylePlain` and `UITableViewStyleGrouped`, there are several differences between them, the most obvious distinction is on displaying.

![](/images/uitableview-overview/diff_of_table_view_style.jpg)

In `Plain` style, table view's default background color is clear color, extra rows are shown with blank and separated by separator line, and there is no header or footer displayed if you do not configure.
However in `Grouped` style, table view has default background color which is `#EFEFF4`, no extra rows will be shown and every section has default header and footer.

> Hint
> if you want to hide all extra rows in Plain style, you can simply set tableView's footer a blank UIView.
> `tableView.tableFooterView = [UIView new];`

There are some other differences, we will talk later on.

**Configuration**

UITableView needs a data source to know how many sections the tableview has and how many rows it has in the specified section. Also, there are lots of information that we need to provide to let table view know how to construct itself. Thus we need to assign `UITableViewDelegate` and `UITableViewDataSource` to table view.

Normally, we set the current view controller as table view's `dataSource` and `delegate`, and implement some protocol methods in it.

```
@interface MyViewController <UITableViewDataSource, UITableViewDelegate>
...
tableView.dataSource = self;
tableView.delegate   = self;
```

Two methods in UITableViewDataSource are required to implement:

```
// How many rows the specified section contains
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;
// What view does every row has
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
```

It is important to notify the table view what view should every row display. 
And this view, we typically name it `Cell`, could be a predefined style or a customized style, has many functions and is the most important element in a table view.

An index path define the position of each cell, it much easier to locate.

```
@interface NSIndexPath (UITableView)
+ (instancetype)indexPathForRow:(NSInteger)row inSection:(NSInteger)section;
@property (nonatomic, readonly) NSInteger section;
@property (nonatomic, readonly) NSInteger row;
@end
```

Well, if you know a little about memory, you may ask 'what if there are a large number of rows I need to display, will table view create the same number of cells?'.
Good question. Provided that if a batch of cells are created, there must be a lot of memory cost. So, Apple has a very elegant mechanism about how to reuse every cell.

Cell Identifier - a unique symbol for every reused cell. UITableView has two methods to get a UITableViewCell instance with a cell identifier,

```
- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;
- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
```

All cells are stored in a queue or list for the later use. As soon as the table view is initialized, the cells which will be displayed on screen (visible cells) are generated by calling delegate method(`tableView:cellForRowAtIndexPath:`).

Both of the two methods can return a cell by searching the associated identifier in the queue or list. If no cell is found in it, the table view will create a cell. 

```
- (void)registerNib:(nullable UINib *)nib forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(5_0);
- (void)registerClass:(nullable Class)cellClass forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);
```

There are two types of creation, one is nib, another is class. You need to register one of them after initializing table view, cause these nibs or classes are used to create associated cells if the reuse queue does not contain the cell with the specified identifier.

Notice that `dequeueReusableCellWithIdentifier:` returns nil if the identifier was not registered, while `dequeueReusableCellWithIdentifier:forIndexPath:` method will raise an exception.

> Hint : If you create a table view and table view cell in storyboard, you do not need to register the cell, cause IB (interface builder) will automatically create a nib and register while table view is loading.

> If table view registers a nib, `initWithCoder:` will be called to create a cell, while `initWithStyle:reuseIdentifier:` is called if table view registers a class.






